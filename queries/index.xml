<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Queries on BMEG</title>
    <link>https://bmeg.github.io/queries/</link>
    <description>Recent content in Queries on BMEG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://bmeg.github.io/queries/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Drug Response</title>
      <link>https://bmeg.github.io/queries/drug_response/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bmeg.github.io/queries/drug_response/</guid>
      <description>Get all CCLE samples q = O.query().V().where(aql.eq(&amp;quot;_label&amp;quot;, &amp;quot;Biosample&amp;quot;)) q = q.where(aql.and_(aql.eq(&amp;quot;source&amp;quot;, &amp;quot;ccle&amp;quot;))).render({&amp;quot;id&amp;quot;:&amp;quot;_gid&amp;quot;}) all_samples = [] for row in q: all_samples.append(row.id)  Genes we&amp;rsquo;ll be looking at GENES = [&amp;quot;CDKN2A&amp;quot;, &amp;quot;PTEN&amp;quot;, &amp;quot;TP53&amp;quot;, &amp;quot;SMAD4&amp;quot;] gene_ids = {} for g in GENES: for i in O.query().V().where(aql.eq(&amp;quot;_label&amp;quot;, &amp;quot;Gene&amp;quot;)).where(aql.eq(&amp;quot;symbol&amp;quot;, g)): gene_ids[g] = i.gid  Scan CCLE cell lines based on mutation status mut_samples = {} norm_samples = {} for g, i in gene_ids.items(): #get CCLE samples with mutation mut_samples[g] = set(k[&#39;gid&#39;] for k in O.</description>
    </item>
    
    <item>
      <title>Getting Started</title>
      <link>https://bmeg.github.io/queries/getting_started/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bmeg.github.io/queries/getting_started/</guid>
      <description>Usage AQL is an API for making graph queries using structured data. Queries are defined using a series of step operations provided by BMEG. The python client wraps the construction of these queries in an intuitive python interface.
Let&amp;rsquo;s go through the features currently supported in the AQL python client.
import First, import the AQL client and create a connection to an existing AQL API:
import aql conn = aql.</description>
    </item>
    
    <item>
      <title>Install</title>
      <link>https://bmeg.github.io/queries/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bmeg.github.io/queries/install/</guid>
      <description> Ophion Python Client pip install &amp;quot;git+https://github.com/bmeg/arachne.git#subdirectory=aql/python&amp;quot;  </description>
    </item>
    
    <item>
      <title>Kaplan Meier Curves</title>
      <link>https://bmeg.github.io/queries/kaplan_meier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bmeg.github.io/queries/kaplan_meier/</guid>
      <description>Make Kaplan Meier curves using TCGA data from lifelines import KaplanMeierFitter import pandas import aql conn = aql.Connection(&amp;quot;http://bmeg.io&amp;quot;) O = conn.graph(&amp;quot;bmeg&amp;quot;) q = O.query().V().where(aql.eq(&amp;quot;_label&amp;quot;, &amp;quot;Individual&amp;quot;)) q = q.where(aql.and_(aql.eq(&amp;quot;source&amp;quot;, &amp;quot;tcga&amp;quot;), aql.eq(&amp;quot;disease_code&amp;quot;, &amp;quot;BRCA&amp;quot;))) q = q.where(aql.eq(&amp;quot;vital_status&amp;quot;, &amp;quot;Dead&amp;quot;)) q1 = q.where(aql.eq(&#39;her2_status_by_ihc&#39;, &#39;Positive&#39;)).render([&amp;quot;death_days_to&amp;quot;]) q2 = q.where(aql.eq(&#39;her2_status_by_ihc&#39;, &#39;Negative&#39;)).render([&amp;quot;death_days_to&amp;quot;]) days_a = list(int(a[0]) for a in q1) days_b = list(int(a[0]) for a in q2) kmf = KaplanMeierFitter() kmf.fit(days_a, label=&amp;quot;HER2 Positive&amp;quot;) ax = kmf.plot() kmf.fit(days_b, label=&amp;quot;HER2 Negative&amp;quot;) kmf.</description>
    </item>
    
    <item>
      <title>Matrix</title>
      <link>https://bmeg.github.io/queries/matrix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bmeg.github.io/queries/matrix/</guid>
      <description> Using BMEG to get matrix data Many vertices in the BMEG contain complex data that can be collected and converted into matrix data.
Download RNA-Seq for cohort:TCGA-READ import pandas import aql conn = aql.Connection(&amp;quot;http://bmeg.io&amp;quot;) O = conn.graph(&amp;quot;bmeg&amp;quot;) c = O.query().V().where(aql.eq(&amp;quot;_label&amp;quot;, &amp;quot;Individual&amp;quot;)) c = c.where(aql.and_(aql.eq(&amp;quot;source&amp;quot;, &amp;quot;tcga&amp;quot;), aql.eq(&amp;quot;disease_code&amp;quot;, &amp;quot;READ&amp;quot;))) c = c.in_(&amp;quot;sampleOf&amp;quot;).in_(&amp;quot;expressionFor&amp;quot;) c = c.render([&amp;quot;$.biosampleId&amp;quot;, &amp;quot;$.expressions&amp;quot;]) data = {} for row in c: data[row[0]] = row[1] samples = pandas.DataFrame(data).transpose().fillna(0.0)  </description>
    </item>
    
    <item>
      <title>Traversal</title>
      <link>https://bmeg.github.io/queries/traversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://bmeg.github.io/queries/traversal/</guid>
      <description>Starting Traversal .V([ids]) Start query from Vertex
O.query().V()  Returns all vertices in graph
O.query().V(&amp;quot;vertex1&amp;quot;)  Returns:
{&amp;quot;gid&amp;quot; : &amp;quot;vertex1&amp;quot;, &amp;quot;label&amp;quot;:&amp;quot;TestVertex&amp;quot;, &amp;quot;data&amp;quot;:{}}  .E() Start query from Edge
O.query().E()  Returns all edges in graph
Filtering .where() Filter elements using conditional statements
O.query().V().where(aql.eq(&amp;quot;_label&amp;quot;, &amp;quot;Gene&amp;quot;)).where(aql.eq(&amp;quot;symbol&amp;quot;, &amp;quot;TP53&amp;quot;))  Conditions Conditions are arguments to .where() that define selection conditions
aql.eq(variable, value) Returns rows where variable == value
.where(aql.eq(&amp;quot;symbol&amp;quot;, &amp;quot;TP53&amp;quot;))  aql.neq(variable, value) Returns rows where variable !</description>
    </item>
    
  </channel>
</rss>